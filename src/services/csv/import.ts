import dataprovider from '../dataprovider';
import { EquivalentEntry } from '../types';

/**
 * A CSV file like this is given from an upload:
 * ID;Scope;Kategorie;Spezifikation 1;Spezifikation 2;Spezifikation 3;Zusatzname;Kommentar;Eingang;Ausgang;Quelle;Faktor;Monatliche Eingaben;Wert-Jan (monatlich);Wert Feb (monatlich);Wert Mar (monatlich);Wert Apr (monatlich);Wert May (monatlich);Wert Jun (monatlich);Wert Jul (monatlich);Wert Aug (monatlich);Wert Sep (monatlich);Wert Oct (monatlich);Wert Nov (monatlich);Wert Dec (monatlich);Überliegende Berechnung (ID);Projekt
 * 56ueccumbbichfm;3;Mineralien und Baustoffe; Bausand; Bausand;;;;kg;kg;EEW 2023;0,005;0;0;0;0;0;0;0;0;0;0;0;0;0;;
 * 728r18m9meqoz1y;1;Technische Gase; Fluorethan;;;;;kg;kg;UBA;12;0;0;0;0;0;0;0;0;0;0;0;0;0;;
 *
 * It needs to be inserted into the database. First it needs to be parsed and checked for errors.
 * Then it needs to be sorted that all entries with a "parent" are inserted after the parent.
 * The given "ID" will be removed. It will be replaced by a ID generated by the database.
 * The parent ID from some entries needs to be replaced by the generated ID.
 */

/**
 * Parse the CSV file and check for errors
 */
export const parseAndCheckFromText = (csv: string): EquivalentEntry[] => {
  const lines = csv.split('\r\n');
  const entries: EquivalentEntry[] = [];
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const parts = line.split(';');
    if (parts.length < 25) {
      throw new Error(`Line ${i + 1} has not 24 parts`);
    }
    const entry: EquivalentEntry = {
      id: parts[0],
      scope: parseInt(parts[1], 10),
      category: parts[2],
      specification1: parts[3],
      specification2: parts[4],
      specification3: parts[5],
      add_name1: parts[6],
      comment: parts[7],
      source: parts[10],
      avg_value: parseFloat(parts[11].replace(',', '.')),
      monthly_values: parts[12] === '1',
      jan: parts[13] === '0' ? null : parseFloat(parts[13].replace(',', '.')),
      feb: parts[14] === '0' ? null : parseFloat(parts[14].replace(',', '.')),
      mar: parts[15] === '0' ? null : parseFloat(parts[15].replace(',', '.')),
      apr: parts[16] === '0' ? null : parseFloat(parts[16].replace(',', '.')),
      may: parts[17] === '0' ? null : parseFloat(parts[17].replace(',', '.')),
      jun: parts[18] === '0' ? null : parseFloat(parts[18].replace(',', '.')),
      jul: parts[19] === '0' ? null : parseFloat(parts[19].replace(',', '.')),
      aug: parts[20] === '0' ? null : parseFloat(parts[20].replace(',', '.')),
      sep: parts[21] === '0' ? null : parseFloat(parts[21].replace(',', '.')),
      oct: parts[22] === '0' ? null : parseFloat(parts[22].replace(',', '.')),
      nov: parts[23] === '0' ? null : parseFloat(parts[23].replace(',', '.')),
      dec: parts[24] === '0' ? null : parseFloat(parts[24].replace(',', '.')),
      parent: parts[25] === '' ? null : parts[25],
      in: parts[8],
      out: parts[9],
      project: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    entries.push(entry);
  }
  return entries;
};

/**
 * Read a string from a file
 */
export const getStringFromFile = async (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result;
      if (typeof result !== 'string') {
        reject(new Error('File is not a string'));
      } else {
        resolve(result);
      }
    };
    reader.onerror = (e) => {
      reject(new Error('Error while reading file.' + e));
    };
    reader.readAsText(file);
  });
};

/**
 * Import a CSV file into the database
 */
export const importCsvFile = async (file: File): Promise<void> => {
  const csv = await getStringFromFile(file);
  const entries = parseAndCheckFromText(csv);
  // sort entries
  const sortedEntries: EquivalentEntry[] = [];
  const entriesWithParent: EquivalentEntry[] = [];
  for (const entry of entries) {
    if (entry.parent) {
      entriesWithParent.push(entry);
    } else {
      sortedEntries.push(entry);
    }
  }
  for (const entry of entriesWithParent) {
    const parent = sortedEntries.find((e) => e.id === entry.parent);
    if (!parent) {
      throw new Error(`Parent ${entry.parent} not found`);
    }
    sortedEntries.push(entry);
  }
  // insert entries
  for (const entry of sortedEntries) {
    const newEntry = await dataprovider.createEquivalent(entry);
    // replace parent id´s in all entries
    for (const e of sortedEntries) {
      if (e.parent === entry.id) {
        console.log('Replace parent', e.id, entry.id, newEntry.id);
        e.parent = newEntry.id;
      }
    }
  }
  console.log(sortedEntries);
};
